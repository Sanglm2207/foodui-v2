{"ast":null,"code":"var _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar isFunction = _util.isFunction;\nvar createHashMap = _util.createHashMap;\nvar noop = _util.noop;\n\nvar _task = require(\"./task\");\n\nvar createTask = _task.createTask;\n\nvar _component = require(\"../util/component\");\n\nvar getUID = _component.getUID;\n\nvar GlobalModel = require(\"../model/Global\");\n\nvar ExtensionAPI = require(\"../ExtensionAPI\");\n\nvar _model = require(\"../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n/**\n * @module echarts/stream/Scheduler\n */\n\n/**\n * @constructor\n */\n\nfunction Scheduler(ecInstance, api) {\n  // this._pipelineMap = createHashMap();\n  this.ecInstance = ecInstance;\n  this.api = api;\n  this.unfinished;\n  /**\n   * @private\n   * @type {\n   *     [handlerUID: string]: {\n   *         seriesTaskMap?: {\n   *             [seriesUID: string]: Task\n   *         },\n   *         overallTask?: Task\n   *     }\n   * }\n   */\n\n  this._stageTaskMap = createHashMap();\n}\n\nvar proto = Scheduler.prototype; // If seriesModel provided, incremental threshold is check by series data.\n\nproto.getPerformArgs = function (task, isBlock) {\n  // For overall task\n  if (!task.__pipeline) {\n    return;\n  }\n\n  var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n  var pCtx = pipeline.context;\n  var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.incrementalRender) && task.__idxInPipeline > pipeline.bockIndex;\n  return {\n    step: incremental ? pipeline.step : null\n  };\n};\n\nproto.getPipeline = function (pipelineId) {\n  return this._pipelineMap.get(pipelineId);\n};\n/**\n * Current, progressive rendering starts from visual and layout.\n * Always detect render mode in the same stage, avoiding that incorrect\n * detection caused by data filtering.\n * Caution:\n * `updateStreamModes` use `seriesModel.getData()`.\n */\n\n\nproto.updateStreamModes = function (seriesModel, view) {\n  var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n  var data = seriesModel.getData();\n  var dataLen = data.count();\n  var incrementalRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n  var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold');\n  seriesModel.pipelineContext = pipeline.context = {\n    incrementalRender: incrementalRender,\n    large: large\n  };\n};\n\nproto.restorePipelines = function (ecModel) {\n  var scheduler = this;\n  var pipelineMap = scheduler._pipelineMap = createHashMap();\n  ecModel.eachSeries(function (seriesModel) {\n    var progressive = seriesModel.getProgressive();\n    var pipelineId = seriesModel.uid;\n    pipelineMap.set(pipelineId, {\n      id: pipelineId,\n      head: null,\n      tail: null,\n      threshold: seriesModel.getProgressiveThreshold(),\n      progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n      bockIndex: -1,\n      step: progressive || 700,\n      // ??? Temporarily number\n      count: 0\n    });\n    pipe(scheduler, seriesModel, seriesModel.dataTask);\n  });\n};\n\nproto.prepareStageTasks = function (stageHandlers, useClearVisual) {\n  var stageTaskMap = this._stageTaskMap;\n  var ecModel = this.ecInstance.getModel();\n  var api = this.api;\n  each(stageHandlers, function (handler) {\n    var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);\n    handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);\n    handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);\n  }, this);\n};\n\nproto.prepareView = function (view, model, ecModel, api) {\n  var renderTask = view.renderTask;\n  var context = renderTask.context;\n  context.model = model;\n  context.ecModel = ecModel;\n  context.api = api;\n  renderTask.__block = !view.incrementalPrepareRender;\n  pipe(this, model, renderTask);\n};\n\nproto.performDataProcessorTasks = function (stageHandlers, ecModel, payload) {\n  // If we do not use `block` here, it should be considered when to update modes.\n  performStageTasks(this, stageHandlers, ecModel, payload, {\n    block: true\n  });\n}; // opt\n// opt.visualType: 'visual' or 'layout'\n// opt.setDirty\n\n\nproto.performVisualTasks = function (stageHandlers, ecModel, payload, opt) {\n  performStageTasks(this, stageHandlers, ecModel, payload, opt);\n};\n\nfunction performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {\n  opt = opt || {};\n  var unfinished;\n  each(stageHandlers, function (stageHandler, idx) {\n    if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n      return;\n    }\n\n    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n    var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var overallTask = stageHandlerRecord.overallTask;\n\n    if (overallTask) {\n      var overallNeedDirty;\n      var agentStubMap = overallTask.agentStubMap;\n      agentStubMap.each(function (stub) {\n        if (needSetDirty(opt, stub)) {\n          stub.dirty();\n          overallNeedDirty = true;\n        }\n      });\n      overallNeedDirty && overallTask.dirty();\n      updatePayload(overallTask, payload);\n      var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n      // then execute the overall task. And stub will call seriesModel.setData,\n      // which ensures that in the overallTask seriesModel.getData() will not\n      // return incorrect data.\n\n      agentStubMap.each(function (stub) {\n        stub.perform(performArgs);\n      });\n      unfinished |= overallTask.perform(performArgs);\n    } else if (seriesTaskMap) {\n      seriesTaskMap.each(function (task, pipelineId) {\n        if (needSetDirty(opt, task)) {\n          task.dirty();\n        }\n\n        var performArgs = scheduler.getPerformArgs(task, opt.block);\n        performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n        updatePayload(task, payload);\n        unfinished |= task.perform(performArgs);\n      });\n    }\n  });\n\n  function needSetDirty(opt, task) {\n    return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n  }\n\n  scheduler.unfinished |= unfinished;\n}\n\nproto.performSeriesTasks = function (ecModel) {\n  var unfinished;\n  ecModel.eachSeries(function (seriesModel) {\n    // Progress to the end for dataInit and dataRestore.\n    unfinished |= seriesModel.dataTask.perform();\n  });\n  this.unfinished |= unfinished;\n};\n\nproto.plan = function () {\n  // Travel pipelines, check block.\n  this._pipelineMap.each(function (pipeline) {\n    var task = pipeline.tail;\n\n    do {\n      if (task.__block) {\n        pipeline.bockIndex = task.__idxInPipeline;\n        break;\n      }\n\n      task = task.getUpstream();\n    } while (task);\n  });\n};\n\nvar updatePayload = proto.updatePayload = function (task, payload) {\n  payload !== 'remain' && (task.context.payload = payload);\n};\n\nfunction createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n  // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n  // it works but it may cause other irrelevant charts blocked.\n\n  if (stageHandler.createOnAllSeries) {\n    ecModel.eachRawSeries(create);\n  } else if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, create);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(create);\n  }\n\n  function create(seriesModel) {\n    var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n    // Reuse original task instance.\n\n    var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({\n      plan: seriesTaskPlan,\n      reset: seriesTaskReset,\n      count: seriesTaskCount\n    }));\n    task.context = {\n      model: seriesModel,\n      ecModel: ecModel,\n      api: api,\n      useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n      plan: stageHandler.plan,\n      reset: stageHandler.reset,\n      scheduler: scheduler\n    };\n    pipe(scheduler, seriesModel, task);\n  } // Clear unused series tasks.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  seriesTaskMap.each(function (task, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      task.dispose();\n      seriesTaskMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n  || createTask({\n    reset: overallTaskReset\n  });\n  overallTask.context = {\n    ecModel: ecModel,\n    api: api,\n    overallReset: stageHandler.overallReset,\n    scheduler: scheduler\n  }; // Reuse orignal stubs.\n\n  var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries;\n  var overallProgress = true;\n  var isOverallFilter = stageHandler.isOverallFilter; // An overall task with seriesType detected or has `getTargetSeries`, we add\n  // stub in each pipelines, it will set the overall task dirty when the pipeline\n  // progress. Moreover, to avoid call the overall task each frame (too frequent),\n  // we set the pipeline block.\n\n  if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, createStub);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(createStub);\n  } // Otherwise, (usually it is legancy case), the overall task will only be\n  // executed when upstream dirty. Otherwise the progressive rendering of all\n  // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n  // dirty info from upsteam.\n  else {\n    overallProgress = false;\n    each(ecModel.getSeries(), createStub);\n  }\n\n  function createStub(seriesModel) {\n    var pipelineId = seriesModel.uid;\n    var stub = agentStubMap.get(pipelineId) || agentStubMap.set(pipelineId, createTask({\n      reset: stubReset,\n      onDirty: stubOnDirty\n    }));\n    stub.context = {\n      model: seriesModel,\n      overallProgress: overallProgress,\n      isOverallFilter: isOverallFilter\n    };\n    stub.agent = overallTask;\n    stub.__block = overallProgress;\n    pipe(scheduler, seriesModel, stub);\n  } // Clear unused stubs.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  agentStubMap.each(function (stub, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      stub.dispose();\n      agentStubMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context, upstreamContext) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n\n  if (resetDefines.length) {\n    return seriesTaskProgress;\n  }\n}\n\nfunction seriesTaskProgress(params, context) {\n  var data = context.data;\n  var resetDefines = context.resetDefines;\n\n  for (var k = 0; k < resetDefines.length; k++) {\n    var resetDefine = resetDefines[k];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  }\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n\nfunction pipe(scheduler, seriesModel, task) {\n  var pipelineId = seriesModel.uid;\n\n  var pipeline = scheduler._pipelineMap.get(pipelineId);\n\n  !pipeline.head && (pipeline.head = task);\n  pipeline.tail && pipeline.tail.pipe(task);\n  pipeline.tail = task;\n  task.__idxInPipeline = pipeline.count++;\n  task.__pipeline = pipeline;\n}\n\nScheduler.wrapStageHandler = function (stageHandler, visualType) {\n  if (isFunction(stageHandler)) {\n    stageHandler = {\n      overallReset: stageHandler,\n      seriesType: detectSeriseType(stageHandler)\n    };\n  }\n\n  stageHandler.uid = getUID('stageHandler');\n  visualType && (stageHandler.visualType = visualType);\n  return stageHandler;\n};\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  for (var name in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name] = noop;\n  }\n}\n\nvar _default = Scheduler;\nmodule.exports = _default;","map":{"version":3,"sources":["D:/Freelancer/foodui-v2/node_modules/echarts/lib/stream/Scheduler.js"],"names":["_util","require","each","isFunction","createHashMap","noop","_task","createTask","_component","getUID","GlobalModel","ExtensionAPI","_model","normalizeToArray","Scheduler","ecInstance","api","unfinished","_stageTaskMap","proto","prototype","getPerformArgs","task","isBlock","__pipeline","pipeline","_pipelineMap","get","id","pCtx","context","incremental","progressiveEnabled","incrementalRender","__idxInPipeline","bockIndex","step","getPipeline","pipelineId","updateStreamModes","seriesModel","view","uid","data","getData","dataLen","count","incrementalPrepareRender","threshold","large","pipelineContext","restorePipelines","ecModel","scheduler","pipelineMap","eachSeries","progressive","getProgressive","set","head","tail","getProgressiveThreshold","preventIncremental","pipe","dataTask","prepareStageTasks","stageHandlers","useClearVisual","stageTaskMap","getModel","handler","record","reset","createSeriesStageTask","overallReset","createOverallStageTask","prepareView","model","renderTask","__block","performDataProcessorTasks","payload","performStageTasks","block","performVisualTasks","opt","stageHandler","idx","visualType","stageHandlerRecord","seriesTaskMap","overallTask","overallNeedDirty","agentStubMap","stub","needSetDirty","dirty","updatePayload","performArgs","perform","skip","performRawSeries","isSeriesFiltered","setDirty","dirtyMap","performSeriesTasks","plan","getUpstream","seriesType","getTargetSeries","createOnAllSeries","eachRawSeries","create","eachRawSeriesByType","seriesTaskPlan","seriesTaskReset","seriesTaskCount","isVisual","isLayout","dispose","removeKey","overallTaskReset","overallProgress","isOverallFilter","createStub","getSeries","stubReset","onDirty","stubOnDirty","agent","upstreamContext","stubProgress","getDownstream","clearAllVisual","resetDefines","length","seriesTaskProgress","params","k","resetDefine","dataEach","i","start","end","progress","wrapStageHandler","detectSeriseType","legacyFunc","ecModelMock","apiMock","e","mockMethods","eachSeriesByType","type","eachComponent","cond","mainType","subType","target","Clz","name","_default","module","exports"],"mappings":"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","sourcesContent":["var _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar isFunction = _util.isFunction;\nvar createHashMap = _util.createHashMap;\nvar noop = _util.noop;\n\nvar _task = require(\"./task\");\n\nvar createTask = _task.createTask;\n\nvar _component = require(\"../util/component\");\n\nvar getUID = _component.getUID;\n\nvar GlobalModel = require(\"../model/Global\");\n\nvar ExtensionAPI = require(\"../ExtensionAPI\");\n\nvar _model = require(\"../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n\n/**\n * @module echarts/stream/Scheduler\n */\n\n/**\n * @constructor\n */\nfunction Scheduler(ecInstance, api) {\n  // this._pipelineMap = createHashMap();\n  this.ecInstance = ecInstance;\n  this.api = api;\n  this.unfinished;\n  /**\n   * @private\n   * @type {\n   *     [handlerUID: string]: {\n   *         seriesTaskMap?: {\n   *             [seriesUID: string]: Task\n   *         },\n   *         overallTask?: Task\n   *     }\n   * }\n   */\n\n  this._stageTaskMap = createHashMap();\n}\n\nvar proto = Scheduler.prototype; // If seriesModel provided, incremental threshold is check by series data.\n\nproto.getPerformArgs = function (task, isBlock) {\n  // For overall task\n  if (!task.__pipeline) {\n    return;\n  }\n\n  var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n  var pCtx = pipeline.context;\n  var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.incrementalRender) && task.__idxInPipeline > pipeline.bockIndex;\n  return {\n    step: incremental ? pipeline.step : null\n  };\n};\n\nproto.getPipeline = function (pipelineId) {\n  return this._pipelineMap.get(pipelineId);\n};\n/**\n * Current, progressive rendering starts from visual and layout.\n * Always detect render mode in the same stage, avoiding that incorrect\n * detection caused by data filtering.\n * Caution:\n * `updateStreamModes` use `seriesModel.getData()`.\n */\n\n\nproto.updateStreamModes = function (seriesModel, view) {\n  var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n  var data = seriesModel.getData();\n  var dataLen = data.count();\n  var incrementalRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n  var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold');\n  seriesModel.pipelineContext = pipeline.context = {\n    incrementalRender: incrementalRender,\n    large: large\n  };\n};\n\nproto.restorePipelines = function (ecModel) {\n  var scheduler = this;\n  var pipelineMap = scheduler._pipelineMap = createHashMap();\n  ecModel.eachSeries(function (seriesModel) {\n    var progressive = seriesModel.getProgressive();\n    var pipelineId = seriesModel.uid;\n    pipelineMap.set(pipelineId, {\n      id: pipelineId,\n      head: null,\n      tail: null,\n      threshold: seriesModel.getProgressiveThreshold(),\n      progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n      bockIndex: -1,\n      step: progressive || 700,\n      // ??? Temporarily number\n      count: 0\n    });\n    pipe(scheduler, seriesModel, seriesModel.dataTask);\n  });\n};\n\nproto.prepareStageTasks = function (stageHandlers, useClearVisual) {\n  var stageTaskMap = this._stageTaskMap;\n  var ecModel = this.ecInstance.getModel();\n  var api = this.api;\n  each(stageHandlers, function (handler) {\n    var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);\n    handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);\n    handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);\n  }, this);\n};\n\nproto.prepareView = function (view, model, ecModel, api) {\n  var renderTask = view.renderTask;\n  var context = renderTask.context;\n  context.model = model;\n  context.ecModel = ecModel;\n  context.api = api;\n  renderTask.__block = !view.incrementalPrepareRender;\n  pipe(this, model, renderTask);\n};\n\nproto.performDataProcessorTasks = function (stageHandlers, ecModel, payload) {\n  // If we do not use `block` here, it should be considered when to update modes.\n  performStageTasks(this, stageHandlers, ecModel, payload, {\n    block: true\n  });\n}; // opt\n// opt.visualType: 'visual' or 'layout'\n// opt.setDirty\n\n\nproto.performVisualTasks = function (stageHandlers, ecModel, payload, opt) {\n  performStageTasks(this, stageHandlers, ecModel, payload, opt);\n};\n\nfunction performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {\n  opt = opt || {};\n  var unfinished;\n  each(stageHandlers, function (stageHandler, idx) {\n    if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n      return;\n    }\n\n    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n    var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var overallTask = stageHandlerRecord.overallTask;\n\n    if (overallTask) {\n      var overallNeedDirty;\n      var agentStubMap = overallTask.agentStubMap;\n      agentStubMap.each(function (stub) {\n        if (needSetDirty(opt, stub)) {\n          stub.dirty();\n          overallNeedDirty = true;\n        }\n      });\n      overallNeedDirty && overallTask.dirty();\n      updatePayload(overallTask, payload);\n      var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n      // then execute the overall task. And stub will call seriesModel.setData,\n      // which ensures that in the overallTask seriesModel.getData() will not\n      // return incorrect data.\n\n      agentStubMap.each(function (stub) {\n        stub.perform(performArgs);\n      });\n      unfinished |= overallTask.perform(performArgs);\n    } else if (seriesTaskMap) {\n      seriesTaskMap.each(function (task, pipelineId) {\n        if (needSetDirty(opt, task)) {\n          task.dirty();\n        }\n\n        var performArgs = scheduler.getPerformArgs(task, opt.block);\n        performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n        updatePayload(task, payload);\n        unfinished |= task.perform(performArgs);\n      });\n    }\n  });\n\n  function needSetDirty(opt, task) {\n    return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n  }\n\n  scheduler.unfinished |= unfinished;\n}\n\nproto.performSeriesTasks = function (ecModel) {\n  var unfinished;\n  ecModel.eachSeries(function (seriesModel) {\n    // Progress to the end for dataInit and dataRestore.\n    unfinished |= seriesModel.dataTask.perform();\n  });\n  this.unfinished |= unfinished;\n};\n\nproto.plan = function () {\n  // Travel pipelines, check block.\n  this._pipelineMap.each(function (pipeline) {\n    var task = pipeline.tail;\n\n    do {\n      if (task.__block) {\n        pipeline.bockIndex = task.__idxInPipeline;\n        break;\n      }\n\n      task = task.getUpstream();\n    } while (task);\n  });\n};\n\nvar updatePayload = proto.updatePayload = function (task, payload) {\n  payload !== 'remain' && (task.context.payload = payload);\n};\n\nfunction createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n  // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n  // it works but it may cause other irrelevant charts blocked.\n\n  if (stageHandler.createOnAllSeries) {\n    ecModel.eachRawSeries(create);\n  } else if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, create);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(create);\n  }\n\n  function create(seriesModel) {\n    var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n    // Reuse original task instance.\n\n    var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({\n      plan: seriesTaskPlan,\n      reset: seriesTaskReset,\n      count: seriesTaskCount\n    }));\n    task.context = {\n      model: seriesModel,\n      ecModel: ecModel,\n      api: api,\n      useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n      plan: stageHandler.plan,\n      reset: stageHandler.reset,\n      scheduler: scheduler\n    };\n    pipe(scheduler, seriesModel, task);\n  } // Clear unused series tasks.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  seriesTaskMap.each(function (task, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      task.dispose();\n      seriesTaskMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n  || createTask({\n    reset: overallTaskReset\n  });\n  overallTask.context = {\n    ecModel: ecModel,\n    api: api,\n    overallReset: stageHandler.overallReset,\n    scheduler: scheduler\n  }; // Reuse orignal stubs.\n\n  var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries;\n  var overallProgress = true;\n  var isOverallFilter = stageHandler.isOverallFilter; // An overall task with seriesType detected or has `getTargetSeries`, we add\n  // stub in each pipelines, it will set the overall task dirty when the pipeline\n  // progress. Moreover, to avoid call the overall task each frame (too frequent),\n  // we set the pipeline block.\n\n  if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, createStub);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(createStub);\n  } // Otherwise, (usually it is legancy case), the overall task will only be\n  // executed when upstream dirty. Otherwise the progressive rendering of all\n  // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n  // dirty info from upsteam.\n  else {\n      overallProgress = false;\n      each(ecModel.getSeries(), createStub);\n    }\n\n  function createStub(seriesModel) {\n    var pipelineId = seriesModel.uid;\n    var stub = agentStubMap.get(pipelineId) || agentStubMap.set(pipelineId, createTask({\n      reset: stubReset,\n      onDirty: stubOnDirty\n    }));\n    stub.context = {\n      model: seriesModel,\n      overallProgress: overallProgress,\n      isOverallFilter: isOverallFilter\n    };\n    stub.agent = overallTask;\n    stub.__block = overallProgress;\n    pipe(scheduler, seriesModel, stub);\n  } // Clear unused stubs.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  agentStubMap.each(function (stub, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      stub.dispose();\n      agentStubMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context, upstreamContext) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n\n  if (resetDefines.length) {\n    return seriesTaskProgress;\n  }\n}\n\nfunction seriesTaskProgress(params, context) {\n  var data = context.data;\n  var resetDefines = context.resetDefines;\n\n  for (var k = 0; k < resetDefines.length; k++) {\n    var resetDefine = resetDefines[k];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  }\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n\nfunction pipe(scheduler, seriesModel, task) {\n  var pipelineId = seriesModel.uid;\n\n  var pipeline = scheduler._pipelineMap.get(pipelineId);\n\n  !pipeline.head && (pipeline.head = task);\n  pipeline.tail && pipeline.tail.pipe(task);\n  pipeline.tail = task;\n  task.__idxInPipeline = pipeline.count++;\n  task.__pipeline = pipeline;\n}\n\nScheduler.wrapStageHandler = function (stageHandler, visualType) {\n  if (isFunction(stageHandler)) {\n    stageHandler = {\n      overallReset: stageHandler,\n      seriesType: detectSeriseType(stageHandler)\n    };\n  }\n\n  stageHandler.uid = getUID('stageHandler');\n  visualType && (stageHandler.visualType = visualType);\n  return stageHandler;\n};\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  for (var name in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name] = noop;\n  }\n}\n\nvar _default = Scheduler;\nmodule.exports = _default;"]},"metadata":{},"sourceType":"script"}